

def get_image_details_keV(file_names, sort=False): # todo update to look like other get_image_details code
    """
    Returns the data loaded from the tif files with a floor subtracted based on the median of the corner. Also returns arrays with the stage
    positions, the file order number, and the number of counts per image.

    Arguments:
    data_array (numpy.ndarray): Numpy data array containing the diffraction images.
    file_names = ['image001_10.tif', 'image002_20.tif', 'image004_40.tif', 'image003_30.tif', 'image004_40.tif']

    Returns:
    data_array (ndarray): Array of N x 1024 x 1024 where N is the length of tile file_names list. Generated by using tifffile as tf.
    stage_pos (array): Default. A numpy array containing the stage positions of the file. The index of each stage position corresponds to
                            the index of the file name in file_names.
    file_order (array): Returns the image number located in the file name. Reflects the order with which the images are taken.
    counts(ndarray): One dimensional numpy array of length N containing the data after summing over each array element.

    """
    data_array = tf.imread(file_names)  # construct array containing files

    try:
        ir_stage_pos = []
        uv_stage_pos = []
        file_order = []
        current = []
        try:
            for file in file_names:
                string = list(map(str, file.split("/")))
                string = list(map(str, string[-1].split("_")))
                file_number = int(string[1])
                file_order.append(file_number)
                ir_stage_pos.append(float(string[4]))
                uv_stage_pos.append(float(string[6]))
                current.append(float(string[-1][:-5]))
        except ValueError:
            raise ValueError("""Failed to convert a file name to a float. Make sure that index positions are correct for all files in file_names. 
            Also check separators""")
    except IndexError:
        raise ValueError(
            "Invalid index values. Make sure the index values are within the range of the file name strings.")

    ir_stage_pos = np.array(ir_stage_pos)
    uv_stage_pos = np.array(uv_stage_pos)
    file_order = np.array(file_order)
    current = np.array(current)
    counts = get_counts(data_array)

    if sort == True:
        temp_idx = sort_files(file_order, ir_stage_pos, uv_stage_pos)
        data_array = data_array[temp_idx]
        ir_stage_pos = ir_stage_pos[temp_idx]
        uv_stage_pos = uv_stage_pos[temp_idx]
        file_order = file_order[temp_idx]
        current = current[temp_idx]
        counts = counts[temp_idx]

    return data_array, ir_stage_pos, uv_stage_pos, file_order, counts, current


def sort_files(file_order, ir_stage_pos, uv_stage_pos):
    uni_stage_ir = np.unique(ir_stage_pos)  # Pump-probe stage position
    uni_stage_uv = np.unique(uv_stage_pos)

    if len(uni_stage_ir) > 1:
        stage_positions = ir_stage_pos
        print("sorting based on IR stage position")
    elif len(uni_stage_uv) > 1:
        stage_positions = uv_stage_pos
        print("sorting based on UV stage position")
    else:
        print("Bad Stage Positions")
    idx_list = []
    uni_stage = np.unique(stage_positions)
    for i in range(len(uni_stage)):
        # file_numbers = file_order[np.where(stage_positions==uni_stage[i])[0]];
        # file_numbers = file_numbers[idx_temp]
        stage_idx = np.where(stage_positions == uni_stage[i])[0]
        file_numbers = file_order[stage_idx]
        idx_temp = np.argsort(file_numbers)
        # print(file_numbers[idx_temp])
        idx_list.append(stage_idx[idx_temp])
    idx_list = np.array(idx_list)
    idx_list = np.reshape(idx_list, len(stage_positions))
    return idx_list